
import { useEffect, useRef } from "react";
import React from "react";
import { propTypes } from "react-latex";
import * as THREE from "three";
import constraint from './constraint.mp3'
import fbd0bq_final from './fbd0bq_final.mp3'
import fbd1bq_final from './fbd1bq_final.mp3'
import fbd3bq_final from './fbd3bq_final.mp3'
import fbd0bq_initial from './fbd0bq_initial.mp3'
import fbd1bq_initial from './fbd1bq_initial.mp3'
//import fbd3bq_final from './fbd3bq_final.mp3'
import unk0_before from './Unk0_before.mp3'
import unk1_before from './unk1_before.mp3'


const TestThree = (props) => {

    const mountRef = useRef(null);

    useEffect(() => {
        const scene = new THREE.Scene()
        //******************************************SHIVAM CODE STARTS */      
        const loader = new THREE.FontLoader();

        /**
                * Lights
                **/

        // Add a point light with #fff color, .7 intensity, and 0 distance
        var light = new THREE.PointLight(0xffffff, 1, 0);
        // Specify the light's position
        light.position.set(1, 1, 100);
        // Add the light to the scene
        scene.add(light)
        /// sheersha code end for text
        // var step = "constraint"; // motion -> fbd -> constraint
        // var substep = 2; // for fbd it goes from 1 to n_b + n_p , for contraint 1 to n_s 
        // var subsubstep =0 // 1 and 2 - used only for contraint , signifie sthe ends 
        console.log("props")
        console.log(props)
        var step = props.threejsstep; // motion -> fbd -> constraint
        var substep = props.threejssubstep; // for fbd it goes from 1 to n_b + n_p , for contraint 1 to n_s 
        var subsubstep = props.threejssubsubstep; // 1 and 2 - used only for contraint , signifie sthe ends 
        var uselessvar = 0.55



        debugger
        const music = new Audio('C:/Users/Shivam Saxena/Desktop/constraint.mp3');

        // const audio = new Audio(constraint)
        // audio.play(); 
        var audio;
        var fbdf_audio = [fbd0bq_final, fbd1bq_final, fbd3bq_final, fbd3bq_final]
        var fbdi_audio = [fbd0bq_initial, fbd1bq_initial]
        var unkb_audio = [unk0_before, unk1_before]

        if (step == "motion" && substep == 0) {
            let player = document.getElementById('radio');
            player.src = unkb_audio[0];
            player.play()
            // audio = new Audio(unkb_audio[0])
            // audio.play();
        }

        if (step == "motion" && substep == 1) {
            let player = document.getElementById('radio');
            player.pause();
            audio = new Audio(unkb_audio[1])
            // audio.play();
        }



        const image = new Image()
        const texture = new THREE.Texture(image)
        image.addEventListener('load', () => {
            texture.needsUpdate = true
        })
        //image.src = '/textures/door/color.jpg'
        image.src = 'door.jpg'




        //var loader = new THREE.JSONLoader();
        //alldata =  fetch("C:/Users/Shivam Saxena/Desktop/alldata.json").then(results=> results.json() ).then(console.log);
        var alld_question_no = "14"
        const alldata = require("./alldata" + alld_question_no + ".json");
        //console.log(alldata);
        const blockdata = alldata["block dick"];
        const pulleydata = alldata["pulley dick"]
        const stringdata = alldata["string dick"]
        const ceilingdata = alldata["ceiling dick"]
        //console.log(pulleydata)
        var n_b = Object.keys(blockdata).length;
        //console.log(stringdata)    
        var n_p = Object.keys(pulleydata).length;
        const n_s = Object.keys(stringdata).length;
        var n_c = Object.keys(ceilingdata).length;

        var i;

        //n_p =0
        var meshk = new Array(n_b);
        var meshpl = new Array(n_c);
        var block_ini_pos_x = new Array(n_b);
        var block_ini_pos_y = new Array(n_b);
        var pulley_ini_pos_x = new Array(n_p);
        var pulley_ini_pos_y = new Array(n_p);
        var text_loc_x = new Array(n_b);
        var text_loc_y = new Array(n_b);
        var acc_arrow_to
        var acc_arrow_from
        var acc_arrow_direction

        var acc_arrow_length
        var acc_arrowHelper = new Array(n_b)
        var acc_cone = new Array(n_b)
        const geometryc = new THREE.ConeGeometry(0.1, 0.2, 32);
        const materialc = new THREE.MeshBasicMaterial({ color: 0xffffff });

        var clr = [0xff0000, 0xffff00, 0x0000ff, 0x00ff00]

        for (i = 1; i < n_b + 1; i++) {

            //const material = new THREE.MeshNormalMaterial()
            const materialx = new THREE.MeshStandardMaterial()
            //const material2 = new THREE.MeshMatcapMaterial()
            //materialx.map = texture
            materialx.color = new THREE.Color(clr[i - 1])
            meshk[i - 1] = new THREE.Mesh(
                new THREE.BoxGeometry(blockdata[i].size[0] / 15, blockdata[i].size[0] / 15, blockdata[i].size[1] / 15),
                materialx);
            //debugger
            if (!step.includes("constraint") || (step == "constraint" && (subsubstep == 0 || subsubstep == -1))) {
                scene.add(meshk[i - 1])


            }
            if (step == "constraint" && (stringdata[substep]["first obj type"] == "<class 'blocksclass.blocks'>" || stringdata[substep]["second obj type"] == "<class 'blocksclass.blocks'>")) {
                if (stringdata[substep]["first obj type"] == "<class 'blocksclass.blocks'>") {
                    if (stringdata[substep]["first obj"] == i) {
                        scene.add(meshk[i - 1])
                    }


                }
                if (stringdata[substep]["second obj type"] == "<class 'blocksclass.blocks'>") {
                    if (stringdata[substep]["second obj"] == i) {
                        scene.add(meshk[i - 1])
                    }


                }
            }

            meshk[i - 1].position.x = (blockdata[i].loc[0] - 150) / 20;
            meshk[i - 1].position.y = (blockdata[i].loc[1] - 150) / 20;

            block_ini_pos_x[i - 1] = meshk[i - 1].position.x;
            block_ini_pos_y[i - 1] = meshk[i - 1].position.y;
            text_loc_x[i - 1] = meshk[i - 1].position.x + 0.8 * blockdata[i].textloc
            text_loc_y[i - 1] = meshk[i - 1].position.y

            acc_arrow_to = new THREE.Vector3(meshk[i - 1].position.x + 0.8 * blockdata[i].textloc, meshk[i - 1].position.y + 0.5, 0)
            acc_arrow_from = new THREE.Vector3(meshk[i - 1].position.x + 0.8 * blockdata[i].textloc, meshk[i - 1].position.y - 0.5, 0)


            acc_arrow_direction = acc_arrow_to.clone().sub(acc_arrow_from);
            acc_arrow_length = acc_arrow_direction.length();
            acc_arrowHelper[i - 1] = new THREE.ArrowHelper(acc_arrow_direction.normalize(), acc_arrow_from, acc_arrow_length, clr[i - 1]);
            acc_cone[i - 1] = new THREE.Mesh(geometryc, materialx);


            acc_cone[i - 1].position.x = meshk[i - 1].position.x + 0.8 * blockdata[i].textloc;

            if (blockdata[i].acceleration[1] > 0) {
                acc_cone[i - 1].position.y = meshk[i - 1].position.y + 0.5;
            }

            if (blockdata[i].acceleration[1] < 0) {
                acc_cone[i - 1].position.y = meshk[i - 1].position.y - 0.5;


                acc_cone[i - 1].rotation.z = 3.14
            }

            scene.add(acc_arrowHelper[i - 1])
            scene.add(acc_cone[i - 1])


            //debugger




        }
        const geometrypl = new THREE.PlaneGeometry(1.7, 1.7);
        const materialpl = new THREE.MeshBasicMaterial({
            color: 0x964B00, side:
                THREE.DoubleSide
        });
        var x;
        for (x = 1; x < n_c + 1; x++) {




            meshpl[x - 1] = new THREE.Mesh(geometrypl, materialpl);



            meshpl[x - 1].position.x = (ceilingdata[x].loc[0] - 150) / 20;
            meshpl[x - 1].position.y = (ceilingdata[x].loc[1] - 150) / 20 + 1;
            scene.add(meshpl[x - 1])
            meshpl[x - 1].rotation.x = 3.14 / 1.5





            //debugger




        }
        var usevarx = 0

        var usevary = 0
        for (let i = 1; i < n_b + 1; i++) {
            loader.load('Teko_Medium_Regular.json', function (font) {
                const textGeometry_t1 = new THREE.TextGeometry("a" + i, {
                    font: font,
                    size: 0.3,
                    height: 1,
                    curveSegments: 5,
                    bevelEnabled: false,

                });
                const material_t1 = [
                    new THREE.MeshPhongMaterial({ color: clr[i - 1] }), // front
                    new THREE.MeshPhongMaterial({ color: 0x000000 }) // side
                ];
                const textMesh = new THREE.Mesh(textGeometry_t1, material_t1);
                textMesh.castShadow = true


                textMesh.position.y = text_loc_y[i - 1]
                textMesh.position.x = text_loc_x[i - 1]

                //scene.add(textMesh);

            });
        }

        const materialx = new THREE.MeshNormalMaterial()
        const materialy = new THREE.MeshNormalMaterial()
        materialx.map = texture
        materialy.map = texture
        materialx.color = new THREE.Color(0xff0000)
        materialy.color = new THREE.Color(0x00ff00)
        //const materialrdm = new THREE.MeshNormalMaterial()
        var rdm1
        rdm1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            materialx
        )
        rdm1.position.x = -1

        var rdm2
        rdm2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.25, 0.25),
            materialy
        )
        rdm2.position.x = -1
        rdm2.position.y = 0.25
        //scene.add( rdm2)
        //scene.add( rdm1)

        var rdm3
        const materialrdm1 = new THREE.MeshBasicMaterial()
        materialrdm1.color = new THREE.Color(0x0000ff)
        materialrdm1.transparent = true
        materialrdm1.opacity = 0.8
        rdm3 = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.05, 0.25),
            materialrdm1
        )
        rdm3.position.x = -1
        rdm3.position.y = 0.14
        //scene.add( rdm3)



        var meshp = new Array(n_p);
        //var clr = [ 0xff0000, 0xffff00, 0x0088ff, 0x00ff00]  
        for (i = 1; i < n_p + 1; i++) {

            const materialp = new THREE.MeshNormalMaterial()
            //const materialx = new THREE.MeshStandardMaterial()
            //const material2 = new THREE.MeshMatcapMaterial()
            //materialp.map = texture
            //materialp.color = new THREE.Color(clr[i-1])
            meshp[i - 1] = new THREE.Mesh(
                new THREE.CylinderGeometry(pulleydata[i].radius / 20, pulleydata[i].radius / 20, 0.03, 32),
                materialp
            )
            //debugger
            if (!step.includes("constraint") || (step == "constraint" && (subsubstep == 0 || subsubstep == -1))) {
                scene.add(meshp[i - 1])
            }
            if (step == "constraint" && (stringdata[substep]["first obj type"] == "<class 'blocksclass.pulleys'>" || stringdata[substep]["second obj type"] == "<class 'blocksclass.pulleys'>")) {
                if (stringdata[substep]["first obj type"] == "<class 'blocksclass.pulleys'>") {
                    if (stringdata[substep]["first obj"] == i) {
                        scene.add(meshp[i - 1])
                    }


                }
                if (stringdata[substep]["second obj type"] == "<class 'blocksclass.pulleys'>") {
                    if (stringdata[substep]["second obj"] == i) {
                        scene.add(meshp[i - 1])
                    }


                }
            }
            meshp[i - 1].rotation.x = 1.57
            meshp[i - 1].position.x = (pulleydata[i].centre[0] - 150) / 20;
            meshp[i - 1].position.y = (pulleydata[i].centre[1] - 150) / 20;

            pulley_ini_pos_x[i - 1] = meshp[i - 1].position.x;
            pulley_ini_pos_y[i - 1] = meshp[i - 1].position.y;


        }

        //console.log( meshp[0].position.y )



        // Object
        //const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3)
        //const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
        //const mesh = new THREE.Mesh(geometry, material)

        //const material = new THREE.MeshBasicMaterial( { map: texture })
        const material = new THREE.MeshNormalMaterial()
        //const material = new THREE.MeshBasicMaterial()
        material.map = texture
        material.color = new THREE.Color(0xff0000)

        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            material
        )

        const material4 = new THREE.LineBasicMaterial({ color: 0xff00ff }); // pink
        const material5 = new THREE.LineBasicMaterial({ color: 0xff0000 }); // yellow
        //const material4 = new THREE.LineBasicMaterial( { color: 0x00ff00 } ); // lime
        const material6 = new THREE.LineBasicMaterial({ color: 0xffffff }); // white

        var line_materials = [material4, material5, material6, material6, material6]



        const material2 = new THREE.MeshStandardMaterial()
        //const material2 = new THREE.MeshMatcapMaterial()
        material2.map = texture
        material2.color = new THREE.Color(0xff0000)
        //material2.metcap = texture

        material.metalness = 0.45
        material.roughness = 0.65
        const mesh1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            material2
        )
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
        scene.add(ambientLight)


        const pointLight = new THREE.PointLight(0xffffff, 0.5)
        pointLight.position.x = 1
        pointLight.position.y = 0
        pointLight.position.z = 2
        //scene.add(pointLight)





        /*const mesh1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.MeshBasicMaterial({ map: texture })
        )*/
        //scene.add( cylinder );
        //cylinder.position.y = 2
        //cylinder.position.x = 0.2
        //cylinder.rotation.x= 1.57


        //scene.add( cylinder );
        mesh1.position.x = 0.4
        /*
        mesh1.position.z = -1
        mesh1.position.x = 1
        //mesh.position.y = 0
        */
        //mesh.rotation.y = 1
        //debugger


        var spherefbd = []

        for (i = 1; i < n_b + 1; i++) {

            //const material = new THREE.MeshNormalMaterial()
            const materialfbd = new THREE.MeshBasicMaterial()
            //const materialfbd = new THREE.MeshMatcapMaterial()

            materialfbd.color = new THREE.Color(0xffffff)
            materialfbd.transparent = true
            materialfbd.opacity = 0.3
            spherefbd[i - 1] = new THREE.Mesh(
                new THREE.SphereGeometry(0.90, 16, 16),
                materialfbd
            )

            spherefbd[i - 1].position.x = meshk[i - 1].position.x;
            spherefbd[i - 1].position.y = meshk[i - 1].position.y;
            if (step == "fbd" && substep == i) {
                scene.add(spherefbd[i - 1])
            }

        }

        for (i = 1; i < n_p + 1; i++) {

            //const material = new THREE.MeshNormalMaterial()
            const materialfbd = new THREE.MeshBasicMaterial()
            //const materialfbd = new THREE.MeshMatcapMaterial()

            materialfbd.color = new THREE.Color(0xffffff)
            materialfbd.transparent = true
            materialfbd.opacity = 0.3
            spherefbd[i - 1 + n_b] = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 16, 16),
                materialfbd
            )

            spherefbd[i - 1 + n_b].position.x = meshp[i - 1].position.x;
            spherefbd[i - 1 + n_b].position.y = meshp[i - 1].position.y;
            if (step == "fbd" && substep == i + n_b) {
                scene.add(spherefbd[i - 1 + n_b])
            }

        }





        //mesh[0].intersect( spherefbd[0] );
        //meshintersect = cube_three_bsp.toMesh( material4 );

        //scene.add( meshintersect)


        const material3 = new THREE.MeshBasicMaterial()
        //material.map = texture
        material3.color = new THREE.Color(0xaaaa00)

        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 16, 16),
            material3
        )
        sphere.position.x = 1


        //scene.add(mesh)
        //scene.add(mesh1,sphere)

        // Sizes
        const sizes = {
            width: 500,
            height: 450
        }

        //const axesHelper = new THREE.AxesHelper(2)
        //scene.add(axesHelper)



        // Camera
        const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)
        //const camera = new THREE.OrthographicCamera(- 2, 2, 2, - 2, 0.1, 100)
        const aspectRatio = sizes.width / sizes.height
        //const camera = new THREE.OrthographicCamera(- 2 * aspectRatio, 2 * aspectRatio, 2, - 2, 0.1, 100)
        camera.position.z = 7;
        camera.position.x = 2;
        camera.position.y = -0.2;
        scene.add(camera)
        // FLOOR

        //camera.lookAt( mesh.position)

        /// Renderer
        const renderer = new THREE.WebGLRenderer({

            alpha: false
        })
        renderer.setSize(sizes.width, sizes.height)

        //renderer.setClearColorHex( 0x000000, 1 );
        //renderer.render(scene, camera)

        //let time = Date.now()
        //onst elapsedTime = clock.getElapsedTime()


        //const pt2 
        //var angle 
        //const geometryline 
        //var secondobj
        //var linestr 
        //line.geometry.verticesNeedUpdate = true   
        //console.log(line.position)

        const kpt = [];
        /*for( i=1; i < n_s; i++ )
        {
                
                
        kpt.push( new THREE.Vector3( meshk[stringdata[1].first obj - 1].position.x, meshk[stringdata[1].first obj - 1].position.y, meshk[stringdata[1].first obj - 1].position.z )  )
        const secondobj = meshp[ stringdata[1].second obj - 1 ]
        var angle = 3.14- stringdata[1].angle
        const pt2 =  new THREE.Vector3( secondobj.position.x + secondobj.geometry.radiusTop* Math.cos(angle), secondobj.position.x + secondobj.geometry.radiusTop* Math.sin(angle), secondobj.position.z  )
        kpt.push( pt2 );
        const geometryline = new THREE.BufferGeometry().setFromPoints( kpt );
            
        const linestr = new THREE.Line( geometryline, material4 );
        scene.add( linestr )*/



        //}

        //console.log(stringdata[1])
        var pt1
        var pt2
        var secondobj
        var firstobj
        var angle
        var points = []
        var strpart
        var linestr = []
        var endpos = []
        var strpt_acc_y = []
        var endpt_acc_y = []
        //var endpos_second =[]
        console.log(meshk)

        for (i = 1; i < n_s + 1; i++) {
            strpart = stringdata[i];
            //debugger
            //console.log( stringdata[i])
            if (strpart["first obj type"] == "<class 'blocksclass.blocks'>" && strpart["second obj type"] == "<class 'blocksclass.pulleys'>") {
                pt1 = new THREE.Vector3(meshk[stringdata[i]["first obj"] - 1].position.x, meshk[stringdata[i]["first obj"] - 1].position.y, meshk[stringdata[i]["first obj"] - 1].position.z)
                points[i - 1] = []
                endpos[i - 1] = []

                points[i - 1].push(pt1);
                angle = 3.14 - stringdata[i].angle
                secondobj = meshp[stringdata[i]["second obj"] - 1]
                pt2 = new THREE.Vector3(secondobj.position.x + secondobj.geometry.parameters.radiusTop * Math.cos(angle), secondobj.position.y + secondobj.geometry.parameters.radiusTop * Math.sin(angle), secondobj.position.z)
                //console.log( pt2 )
                points[i - 1].push(pt2);
                const geometry4 = new THREE.BufferGeometry().setFromPoints(points[i - 1]);

                if (pt1.y < pt2.y) {
                    pt1.y = pt1.y + 0.6 // box k aadhe size ka karo 
                }
                if (pt2.y < pt1.y) {
                    pt1.y = pt1.y - 0.6 // box k aadhe size ka karo 
                }
                endpos[i - 1].push(pt1)
                endpos[i - 1].push(pt2)



                linestr[i - 1] = new THREE.Line(geometry4, line_materials[strpart["str no"] - 1]);
                if (!step.includes("constraint") || (step == "constraint" && subsubstep <= 0)) {
                    scene.add(linestr[i - 1])
                }
                if (step == "constraint" && i == substep) {
                    scene.add(linestr[i - 1])
                }
            }
            //debugger
            if (strpart["second obj type"] == "<class 'blocksclass.blocks'>" && strpart["first obj type"] == "<class 'blocksclass.pulleys'>") {
                angle = 3.14 - stringdata[i].angle
                firstobj = meshp[stringdata[i]["first obj"] - 1]
                //console.log( firstobj)
                if (strpart["toc"] != "mm") {
                    pt1 = new THREE.Vector3(firstobj.position.x + firstobj.geometry.parameters.radiusTop * Math.cos(angle), firstobj.position.y + firstobj.geometry.parameters.radiusTop * Math.sin(angle), firstobj.position.z)
                }
                else {
                    pt1 = new THREE.Vector3(firstobj.position.x, firstobj.position.y, firstobj.position.z)

                }
                points[i - 1] = []
                points[i - 1].push(pt1);

                pt2 = new THREE.Vector3(meshk[stringdata[i]["second obj"] - 1].position.x, meshk[stringdata[i]["second obj"] - 1].position.y, meshk[stringdata[i]["second obj"] - 1].position.z)

                //console.log( pt2 )
                points[i - 1].push(pt2);
                const geometry4 = new THREE.BufferGeometry().setFromPoints(points[i - 1]);

                if (pt2.y < pt1.y) {
                    pt2.y = pt2.y + 0.6 // box k aadhe size ka karo 
                }
                if (pt1.y < pt2.y) {
                    pt2.y = pt2.y - 0.6 // box k aadhe size ka karo 
                }
                endpos[i - 1] = []
                endpos[i - 1].push(pt1)
                endpos[i - 1].push(pt2)



                linestr[i - 1] = new THREE.Line(geometry4, line_materials[strpart["str no"] - 1]);
                if (!step.includes("constraint") || (step == "constraint" && subsubstep <= 0)) {
                    scene.add(linestr[i - 1])
                }
                if (step == "constraint" && i == substep) {
                    scene.add(linestr[i - 1])
                }
            }

            if (strpart["second obj type"] == "<class 'blocksclass.blocks'>" && strpart["first obj type"] == "<class 'blocksclass.blocks'>") {
                angle = 3.14 - stringdata[i].angle
                firstobj = meshk[stringdata[i]["first obj"] - 1]
                console.log(firstobj)
                pt1 = new THREE.Vector3(meshk[stringdata[i]["first obj"] - 1].position.x, meshk[stringdata[i]["first obj"] - 1].position.y, meshk[stringdata[i]["first obj"] - 1].position.z)
                points[i - 1] = []
                points[i - 1].push(pt1);

                pt2 = new THREE.Vector3(meshk[stringdata[i]["second obj"] - 1].position.x, meshk[stringdata[i]["second obj"] - 1].position.y, meshk[stringdata[i]["second obj"] - 1].position.z)

                console.log(pt2)
                points[i - 1].push(pt2);
                const geometry4 = new THREE.BufferGeometry().setFromPoints(points[i - 1]);

                if (pt2.y < pt1.y) {
                    pt2.y = pt2.y + 0.6 // box k aadhe size ka karo 
                }
                if (pt1.y < pt2.y) {
                    pt2.y = pt2.y - 0.6 // box k aadhe size ka karo 
                }
                endpos[i - 1] = []
                endpos[i - 1].push(pt1)
                endpos[i - 1].push(pt2)

                linestr[i - 1] = new THREE.Line(geometry4, line_materials[strpart["str no"] - 1]);
                if (!step.includes("constraint") || (step == "constraint" && subsubstep <= 0)) {
                    scene.add(linestr[i - 1])
                }
                if (step == "constraint" && i == substep) {
                    scene.add(linestr[i - 1])
                }
            }
            if (strpart["second obj type"] == "<class 'blocksclass.pulleys'>" && strpart["first obj type"] == "<class 'blocksclass.pulleys'>") {
                angle = 3.14 - stringdata[i].angle
                firstobj = meshp[stringdata[i]["first obj"] - 1]
                //console.log( firstobj)
                pt1 = new THREE.Vector3(firstobj.position.x + firstobj.geometry.parameters.radiusTop * Math.cos(angle), firstobj.position.y + firstobj.geometry.parameters.radiusTop * Math.sin(angle), firstobj.position.z)
                points[i - 1] = []
                points[i - 1].push(pt1);

                if (strpart["toc"] == "tm") {
                    pt2 = new THREE.Vector3(meshp[stringdata[i]["second obj"] - 1].position.x, meshp[stringdata[i]["second obj"] - 1].position.y, meshp[stringdata[i]["second obj"] - 1].position.z)
                }
                if (strpart["toc"] == "tz") {
                    pt2 = new THREE.Vector3(meshp[stringdata[i]["second obj"] - 1].position.x - firstobj.geometry.parameters.radiusTop, meshp[stringdata[i]["second obj"] - 1].position.y, meshp[stringdata[i]["second obj"] - 1].position.z)
                }
                if (strpart["toc"] == "zt") {
                    pt2 = new THREE.Vector3(meshp[stringdata[i]["second obj"] - 1].position.x - firstobj.geometry.parameters.radiusTop, meshp[stringdata[i]["second obj"] - 1].position.y, meshp[stringdata[i]["second obj"] - 1].position.z)
                }


                //console.log( pt2 )
                points[i - 1].push(pt2);
                const geometry4 = new THREE.BufferGeometry().setFromPoints(points[i - 1]);


                endpos[i - 1] = []
                endpos[i - 1].push(pt1)
                endpos[i - 1].push(pt2)



                linestr[i - 1] = new THREE.Line(geometry4, line_materials[strpart["str no"] - 1]);
                if (!step.includes("constraint") || (step == "constraint" && subsubstep <= 0)) {
                    scene.add(linestr[i - 1])
                }
                if (step == "constraint" && i == substep) {
                    scene.add(linestr[i - 1])
                }
            }
            if (strpart["second obj type"] == "<class 'blocksclass.grounds'>" && strpart["first obj type"] == "<class 'blocksclass.pulleys'>") {
                angle = 3.14 - stringdata[i].angle
                secondobj = meshpl[stringdata[i]["second obj"] - 1]
                //console.log( firstobj)
                pt2 = new THREE.Vector3(secondobj.position.x, secondobj.position.y, secondobj.position.z)


                if (strpart["toc"] == "mm") {
                    pt1 = new THREE.Vector3(meshp[stringdata[i]["first obj"] - 1].position.x, meshp[stringdata[i]["first obj"] - 1].position.y, meshp[stringdata[i]["second obj"] - 1].position.z)
                }
                if (strpart["toc"] == "zm") {
                    pt1 = new THREE.Vector3(meshp[stringdata[i]["first obj"] - 1].position.x + firstobj.geometry.parameters.radiusTop, meshp[stringdata[i]["first obj"] - 1].position.y, meshp[stringdata[i]["second obj"] - 1].position.z)
                }
                points[i - 1] = []
                points[i - 1].push(pt1);

                //console.log( pt2 )
                points[i - 1].push(pt2);
                const geometry4 = new THREE.BufferGeometry().setFromPoints(points[i - 1]);


                endpos[i - 1] = []
                endpos[i - 1].push(pt1)
                endpos[i - 1].push(pt2)



                linestr[i - 1] = new THREE.Line(geometry4, line_materials[strpart["str no"] - 1]);
                if (!step.includes("constraint") || (step == "constraint" && subsubstep <= 0)) {
                    scene.add(linestr[i - 1])
                }
                if (step == "constraint" && i == substep) {
                    scene.add(linestr[i - 1])
                }
            }
        }
        //debugger
        //console.log(linestr[0])
        //debugger
        /*const points1 =[]
        points1.push( new THREE.Vector3( 0.4,2,0) );
        points1.push( new THREE.Vector3( 0.4, 0 ,0 ) );
        const geometry5 = new THREE.BufferGeometry().setFromPoints( points1 );
            
        const line1 = new THREE.Line( geometry5, material4 );
        scene.add( line1 )*/
        var realpts_x = []
        var realpts_y = []
        var j
        var k
        var slope
        var intercept
        var centre_x
        var centre_y
        var radius
        var alpha
        var beta
        var gamma
        var discriminant
        var x1, x2, y1, y2
        var intersection_x
        var intersection_y1
        var intersection_y2
        var ip_x = new Array(n_b + n_p); // intersection points
        var ip_y = new Array(n_b + n_p); // intersection points y coordinate
        var a_from
        var a_to
        var arrow_from = new Array(n_b + n_p); //new THREE.Vector3( 0, 0.9, 0 );
        var arrow_to = new Array(n_b + n_p);//new THREE.Vector3( 0, 0.9+0.7, 0 );
        var cone = [];
        var arrowHelper = [];
        var arrow_direction;
        var arrow_length


        // finding the cutting points 
        for (i = 0; i < n_b; i++) {
            console.log(meshk[i])
            realpts_x[i] = []
            realpts_y[i] = []
            ip_x[i] = [];
            ip_y[i] = [];
            arrow_from[i] = [];
            arrow_to[i] = [];
            //debugger;
            for (j = 0; j < linestr.length; j++) {

                var endpt1 = [];
                var endpt2 = [];
                if ((stringdata[j + 1]["first obj type"] == "<class 'blocksclass.blocks'>" && (stringdata[j + 1]["first obj"] - 1) == i) ||
                    (stringdata[j + 1]["second obj type"] == "<class 'blocksclass.blocks'>" && (stringdata[j + 1]["second obj"] - 1) == i)) {
                    slope = (linestr[j].geometry.attributes.position.array[1] - linestr[j].geometry.attributes.position.array[4]) / (linestr[j]
                        .geometry.attributes.position.array[0] - linestr[j].geometry.attributes.position.array[3])
                    //console.log(linestr)
                    // debugger
                    if (Math.abs(slope) > 100) {
                        intersection_x = (linestr[j].geometry.attributes.position.array[0] + linestr[j].geometry.attributes.position.array[3]) / 2;
                        if ((stringdata[j + 1]["first obj"] - 1 == i) && stringdata[j + 1]["first obj type"] == "<class 'blocksclass.blocks'>" && (linestr[j].geometry.attributes.position.array[4] > linestr[j].geometry.attributes.position.array[1])) {
                            intersection_y1 = meshk[i].position.y + 0.9
                            a_to = new THREE.Vector3(intersection_x, intersection_y1 + 0.7, 0);
                        }
                        if ((stringdata[j + 1]["second obj"] - 1 == i) && stringdata[j + 1]["second obj type"] == "<class 'blocksclass.blocks'>" && (linestr[j].geometry.attributes.position.array[4] > linestr[j].geometry.attributes.position.array[1])) {
                            intersection_y1 = meshk[i].position.y - 0.9
                            a_to = new THREE.Vector3(intersection_x, intersection_y1 - 0.7, 0);
                        }
                        if ((stringdata[j + 1]["second obj"] - 1 == i) && stringdata[j + 1]["second obj type"] == "<class 'blocksclass.blocks'>" && (linestr[j].geometry.attributes.position.array[1] > linestr[j].geometry.attributes.position.array[4])) {
                            intersection_y1 = meshk[i].position.y + 0.9
                            a_to = new THREE.Vector3(intersection_x, intersection_y1 + 0.7, 0);
                        }


                        ip_x[i].push(intersection_x)
                        ip_y[i].push(intersection_y1)
                        a_from = new THREE.Vector3(intersection_x, intersection_y1, 0);

                        arrow_from[i].push(a_from)
                        arrow_to[i].push(a_to)


                    }
                }

                /*  if( ( stringdata[ j+1 ][ "first obj type" ] == "<class 'blocksclass.blocks'>" && ( stringdata[ j+1 ][ "first obj" ] - 1 ) == i ) 
                  {
                      slope =  ( linestr[j].geometry.attributes.position.array[1] - linestr[j].geometry.attributes.position.array[4] )/ ( linestr[j].
                      geometry.attributes.position.array[0] - linestr[j].geometry.attributes.position.array[3])
                  //console.log(linestr)
          
                  dis_line =  Math.pow( Math.pow( linestr[j].geometry.attributes.position.array[1] - linestr[j].geometry.attributes.position.array[4],2 ) +  Math.pow( linestr[j].
                      geometry.attributes.position.array[0] - linestr[j].geometry.attributes.position.array[3], 2 ), 0.5 );
          
                      cos_theta =  
                      
                          intersection_x = meshk[i].position.x + 0.9 * cos_theta
                          intersection_y1 = meshk[i].position.y + 0.9 
          
                          ip_x[i].push( intersection_x )
                          ip_y[i].push( intersection_y1 )
                          a_from = new THREE.Vector3( intersection_x, intersection_y1, 0 );
                          a_to = new THREE.Vector3( intersection_x, intersection_y1 + 0.7, 0 );
                          arrow_from[i].push( a_from )
                          arrow_to[i].push( a_to )
                          
          
                      
                  } */






                // intercept = linestr[j].geometry.attributes.position.array[1] - slope * linestr[j].geometry.attributes.position.array[0]
                // centre_x = meshk[i].position.x
                // centre_y = meshk[i].position.y
                // radius = spherefbd[i].geometry.parameters.radius

                // alpha = slope * slope + 1
                // beta = (-2 * centre_x ) + ( -2 * slope * centre_y ) + 2* slope * intercept
                // gamma = Math.pow(centre_x,2) + Math.pow( centre_y,2) + Math.pow( intercept,2) - Math.pow( radius,2) - ( 2* intercept* centre_y)

                // discriminant = Math.sqrt(Math.pow(beta,2) - 4* alpha * gamma  )
                // x1 = (- beta + discriminant )/ ( 2* alpha )
                // x2 = (- beta - discriminant )/ ( 2* alpha )

                // y1 = slope * x1 + intercept
                // y2 = slope * x2 + intercept

                // endpt1[0] = linestr[j].geometry.attributes.position.array[0]
                // endpt1[1] = linestr[j].geometry.attributes.position.array[1]

                // endpt2[0] = linestr[j].geometry.attributes.position.array[3]
                // endpt2[1] = linestr[j].geometry.attributes.position.array[4]

                // var dis1_pt1 = Math.sqrt( Math.pow(x1-endpt1[0], 2) + Math.pow(y1-endpt1[1], 2)  )
                // var dis2_pt1 = Math.sqrt( Math.pow(x1-endpt2[0], 2) + Math.pow(y1-endpt2[1], 2)  )

                // var dis1_pt2 = Math.sqrt( Math.pow(x2-endpt1[0], 2) + Math.pow(y2-endpt1[1], 2)  )
                // var dis2_pt2 = Math.sqrt( Math.pow(x2-endpt2[0], 2) + Math.pow(y2-endpt2[1], 2)  )

                // var dis_line = Math.sqrt( Math.pow(endpt1[0]-endpt2[0], 2) + Math.pow( endpt1[1] -endpt2[1], 2)  )

                // if( (dis1_pt1 < dis_line) &&  (dis2_pt1 < dis_line) )
                // {
                //     realpts_x[i][j] = x1
                //     realpts_y[i][j] = y1
                // }
                // else
                // {
                //     realpts_x[i][j] = x2
                //     realpts_y[i][j] = y2
                // }
                // if( realpts_x[i][j] < 10000)
                // {
                // console.log( realpts_x[i][j])
                // }






            }
        }

        for (i = 0; i < n_p; i++) {

            ip_x[i + n_b] = [];
            ip_y[i + n_b] = [];
            arrow_from[i + n_b] = [];
            arrow_to[i + n_b] = [];
            //debugger;
            for (j = 0; j < linestr.length; j++) {

                var endpt1 = [];
                var endpt2 = [];
                if ((stringdata[j + 1]["first obj type"] == "<class 'blocksclass.pulleys'>" && (stringdata[j + 1]["first obj"] - 1) == i) ||
                    (stringdata[j + 1]["second obj type"] == "<class 'blocksclass.pulleys'>" && (stringdata[j + 1]["second obj"] - 1) == i)) {
                    slope = (linestr[j].geometry.attributes.position.array[1] - linestr[j].geometry.attributes.position.array[4]) / (linestr[j]
                        .geometry.attributes.position.array[0] - linestr[j].geometry.attributes.position.array[3])
                    //console.log(linestr)

                    if (Math.abs(slope) > 100) {
                        intersection_x = (linestr[j].geometry.attributes.position.array[0] + linestr[j].geometry.attributes.position.array[3]) / 2;
                        if (stringdata[j + 1]["second obj type"] == "<class 'blocksclass.pulleys'>" && (stringdata[j + 1]["second obj"] - 1) == i) {
                            if (linestr[j].geometry.attributes.position.array[1] > linestr[j].geometry.attributes.position.array[4]) {
                                intersection_y1 = meshp[i].position.y + Math.pow(1.2 * 1.2 - Math.pow(intersection_x - meshp[i].position.x, 2), 0.5);
                                a_to = new THREE.Vector3(intersection_x, intersection_y1 + 0.7, 0);
                            }
                            if (linestr[j].geometry.attributes.position.array[4] > linestr[j].geometry.attributes.position.array[1]) {
                                intersection_y1 = meshp[i].position.y - Math.pow(1.2 * 1.2 - Math.pow(intersection_x - meshp[i].position.x, 2), 0.5);

                                a_to = new THREE.Vector3(intersection_x, intersection_y1 - 0.7, 0);

                            }

                        }
                        if (stringdata[j + 1]["first obj type"] == "<class 'blocksclass.pulleys'>" && (stringdata[j + 1]["first obj"] - 1) == i) {
                            if (linestr[j].geometry.attributes.position.array[1] > linestr[j].geometry.attributes.position.array[4]) {
                                intersection_y1 = meshp[i].position.y - Math.pow(1.2 * 1.2 - Math.pow(intersection_x - meshp[i].position.x, 2), 0.5);
                                a_to = new THREE.Vector3(intersection_x, intersection_y1 - 0.7, 0);
                            }
                            if (linestr[j].geometry.attributes.position.array[4] > linestr[j].geometry.attributes.position.array[1]) {
                                intersection_y1 = meshp[i].position.y + Math.pow(1.2 * 1.2 - Math.pow(intersection_x - meshp[i].position.x, 2), 0.5);
                                a_to = new THREE.Vector3(intersection_x, intersection_y1 + 0.7, 0);
                            }
                        }
                        ip_x[i + n_b].push(intersection_x)
                        ip_y[i + n_b].push(intersection_y1)

                        a_from = new THREE.Vector3(intersection_x, intersection_y1, 0);

                        arrow_from[i + n_b].push(a_from)
                        arrow_to[i + n_b].push(a_to)



                    }
                }



                // intercept = linestr[j].geometry.attributes.position.array[1] - slope * linestr[j].geometry.attributes.position.array[0]
                // centre_x = meshk[i].position.x
                // centre_y = meshk[i].position.y
                // radius = spherefbd[i].geometry.parameters.radius

                // alpha = slope * slope + 1
                // beta = (-2 * centre_x ) + ( -2 * slope * centre_y ) + 2* slope * intercept
                // gamma = Math.pow(centre_x,2) + Math.pow( centre_y,2) + Math.pow( intercept,2) - Math.pow( radius,2) - ( 2* intercept* centre_y)

                // discriminant = Math.sqrt(Math.pow(beta,2) - 4* alpha * gamma  )
                // x1 = (- beta + discriminant )/ ( 2* alpha )
                // x2 = (- beta - discriminant )/ ( 2* alpha )

                // y1 = slope * x1 + intercept
                // y2 = slope * x2 + intercept

                // endpt1[0] = linestr[j].geometry.attributes.position.array[0]
                // endpt1[1] = linestr[j].geometry.attributes.position.array[1]

                // endpt2[0] = linestr[j].geometry.attributes.position.array[3]
                // endpt2[1] = linestr[j].geometry.attributes.position.array[4]

                // var dis1_pt1 = Math.sqrt( Math.pow(x1-endpt1[0], 2) + Math.pow(y1-endpt1[1], 2)  )
                // var dis2_pt1 = Math.sqrt( Math.pow(x1-endpt2[0], 2) + Math.pow(y1-endpt2[1], 2)  )

                // var dis1_pt2 = Math.sqrt( Math.pow(x2-endpt1[0], 2) + Math.pow(y2-endpt1[1], 2)  )
                // var dis2_pt2 = Math.sqrt( Math.pow(x2-endpt2[0], 2) + Math.pow(y2-endpt2[1], 2)  )

                // var dis_line = Math.sqrt( Math.pow(endpt1[0]-endpt2[0], 2) + Math.pow( endpt1[1] -endpt2[1], 2)  )

                // if( (dis1_pt1 < dis_line) &&  (dis2_pt1 < dis_line) )
                // {
                //     realpts_x[i][j] = x1
                //     realpts_y[i][j] = y1
                // }
                // else
                // {
                //     realpts_x[i][j] = x2
                //     realpts_y[i][j] = y2
                // }
                // if( realpts_x[i][j] < 10000)
                // {
                // console.log( realpts_x[i][j])
                // }






            }
        }



        //debugger
        var chotasphere = []

        var cs_count = 0;
        for (i = 1; i < n_b + 1; i++) {
            //debugger
            for (j = 0; j < ip_x[i - 1].length; j++) {

                const materialch = new THREE.MeshBasicMaterial()
                materialch.color = new THREE.Color(0xffffff)
                //materialfbd.transparent = true
                //materialfbd.opacity = 0.8
                chotasphere[cs_count] = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    materialch
                )

                chotasphere[cs_count].position.x = ip_x[i - 1][j];
                chotasphere[cs_count].position.y = ip_y[i - 1][j];

                arrow_direction = arrow_to[i - 1][j].clone().sub(arrow_from[i - 1][j]);
                arrow_length = arrow_direction.length();
                arrowHelper[cs_count] = new THREE.ArrowHelper(arrow_direction.normalize(), arrow_from[i - 1][j], arrow_length, 0xffffff);
                cone[cs_count] = new THREE.Mesh(geometryc, materialc);


                cone[cs_count].position.x = ip_x[i - 1][j];
                cone[cs_count].position.y = arrow_to[i - 1][j].y;//ip_y[i-1][j] + 0.5;

                if (arrow_to[i - 1][j].y < arrow_from[i - 1][j].y) {
                    cone[cs_count].rotation.z = 3.14
                }


                if (step == "fbd" && substep == i && (subsubstep == -100 || subsubstep == j + 1)) {
                    scene.add(chotasphere[cs_count]);
                    if (subsubstep == -100) {
                        audio = new Audio(fbdi_audio[i - 1])
                        // audio.play();
                    }

                }

                if (step == "fbd" && substep == i && (subsubstep > j + 1 || subsubstep == 100)) {
                    scene.add(chotasphere[cs_count]);
                    scene.add(arrowHelper[cs_count]);
                    scene.add(cone[cs_count]);
                    if (subsubstep == 100) {
                        audio = new Audio(fbdf_audio[i - 1])
                        //  audio.play();
                    }
                }



                cs_count = cs_count + 1;




            }


        }

        const materialcs_cu = new THREE.MeshBasicMaterial()
        materialcs_cu.color = new THREE.Color(0xffffff)
        var cs_cu = new Array(2)
        // constraint understaning code begins
        if (step == "constraint Understanding") {
            var velocity_cu = [subsubstep[0] / 10, subsubstep[1] / 10]

            cs_cu[0] = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 16, 16),
                materialcs_cu
            )

            cs_cu[0].position.x = -0.3
            cs_cu[0].position.y = 0

            scene.add(cs_cu[0])

            cs_cu[1] = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 16, 16),
                materialcs_cu
            )

            cs_cu[1].position.x = 4
            cs_cu[1].position.y = 0

            scene.add(cs_cu[1])
            var points_cu = []
            var linestr_cu
            var pt1_cu
            var pt2_cu
            pt1_cu = new THREE.Vector3(cs_cu[0].position.x, cs_cu[0].position.y, cs_cu[0].position.z)
            pt2_cu = new THREE.Vector3(cs_cu[1].position.x, cs_cu[1].position.y, cs_cu[1].position.z)
            // console.log( pt2 )
            points_cu.push(pt1_cu);
            points_cu.push(pt2_cu)
            const geometry_cu = new THREE.BufferGeometry().setFromPoints(points_cu);
            linestr_cu = new THREE.Line(geometry_cu, line_materials[2]);
            scene.add(linestr_cu)

            var arrow_to_cu0 = new THREE.Vector3(cs_cu[0].position.x + velocity_cu[0] / Math.abs(velocity_cu[0]), cs_cu[0].position.y - 0.3, 0)
            var arrow_from_cu0 = new THREE.Vector3(cs_cu[0].position.x, cs_cu[0].position.y - 0.3, 0)


            var arrow_direction_cu0 = arrow_to_cu0.clone().sub(arrow_from_cu0);
            var arrow_length_cu0 = arrow_direction_cu0.length();
            var arrowHelper_cu0 = new THREE.ArrowHelper(arrow_direction_cu0.normalize(), arrow_from_cu0, arrow_length_cu0, 0xffffff);
            var cone_cu0 = new THREE.Mesh(geometryc, materialx);


            cone_cu0.position.x = cs_cu[0].position.x + 0.9 * velocity_cu[0] / Math.abs(velocity_cu[0])


            cone_cu0.position.y = cs_cu[0].position.y - 0.3;
            cone_cu0.rotation.z = -3.14 / 2 * velocity_cu[0] / Math.abs(velocity_cu[0])

            scene.add(cone_cu0)
            scene.add(arrowHelper_cu0)

            var arrow_to_cu1 = new THREE.Vector3(cs_cu[1].position.x + velocity_cu[1] / Math.abs(velocity_cu[1]), cs_cu[1].position.y - 0.3, 0)
            var arrow_from_cu1 = new THREE.Vector3(cs_cu[1].position.x, cs_cu[1].position.y - 0.3, 0)


            var arrow_direction_cu1 = arrow_to_cu1.clone().sub(arrow_from_cu1);
            var arrow_length_cu1 = arrow_direction_cu1.length();
            var arrowHelper_cu1 = new THREE.ArrowHelper(arrow_direction_cu1.normalize(), arrow_from_cu1, arrow_length_cu1, 0xffffff);
            var cone_cu1 = new THREE.Mesh(geometryc, materialx);


            cone_cu1.position.x = cs_cu[1].position.x + 0.9 * velocity_cu[1] / Math.abs(velocity_cu[1])


            cone_cu1.position.y = cs_cu[1].position.y - 0.3;
            cone_cu1.rotation.z = -3.14 / 2 * velocity_cu[1] / Math.abs(velocity_cu[1])

            scene.add(cone_cu1)
            scene.add(arrowHelper_cu1)



        }


        // constraint understanding code ends

        var cs_cons = []

        var cone_constraint = new Array(2 * n_s);
        var line_constraint = new Array(n_s)
        var geometry_cons;
        var cs_count_cons = 0;

        for (i = 1; i < n_s + 1; i++) {
            for (j = 0; j < 2; j++) {

                const materialch = new THREE.MeshBasicMaterial()
                materialch.color = new THREE.Color(0xffffff)
                //materialfbd.transparent = true
                //materialfbd.opacity = 0.8
                cs_cons[cs_count_cons] = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    materialch
                )

                cs_cons[cs_count_cons].position.x = endpos[i - 1][j].x;
                cs_cons[cs_count_cons].position.y = endpos[i - 1][j].y;

                if (step == "constraint" && substep == i && subsubstep > 0) {
                    scene.add(cs_cons[cs_count_cons]);
                }

                // debugger
                cone_constraint[cs_count_cons] = new THREE.Mesh(geometryc, materialc);


                cone_constraint[cs_count_cons].position.x = endpos[i - 1][j].x;
                cone_constraint[cs_count_cons].position.y = endpos[i - 1][j].y;


                if (stringdata[i]["str no"] == substep && subsubstep == 0 && step == "constraint") {
                    scene.add(cone_constraint[cs_count_cons]);

                    if (j == 1) {
                        if (endpos[i - 1][j].y < endpos[i - 1][j - 1].y) {
                            cone_constraint[cs_count_cons].rotation.z = 3.14
                        }
                        else {
                            cone_constraint[cs_count_cons - 1].rotation.z = 3.14
                        }
                    }
                }



















                cs_count_cons = cs_count_cons + 1;




            }

            geometry_cons = new THREE.BufferGeometry().setFromPoints(endpos[i - 1]);





            line_constraint[i - 1] = new THREE.Line(geometry_cons, material6);
            if (stringdata[i]["str no"] == substep && subsubstep == 0 && step == "constraint") {
                scene.add(line_constraint[i - 1])
            }


        }

        for (i = 1; i < n_p + 1; i++) {
            for (j = 0; j < ip_x[i + n_b - 1].length; j++) {

                const materialch = new THREE.MeshBasicMaterial()
                materialch.color = new THREE.Color(0xffffff)
                //materialfbd.transparent = true
                //materialfbd.opacity = 0.8
                chotasphere[cs_count] = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    materialch
                )

                chotasphere[cs_count].position.x = ip_x[i + n_b - 1][j];
                chotasphere[cs_count].position.y = ip_y[i + n_b - 1][j];

                arrow_direction = arrow_to[i + n_b - 1][j].clone().sub(arrow_from[i + n_b - 1][j]);
                arrow_length = arrow_direction.length();
                arrowHelper[cs_count] = new THREE.ArrowHelper(arrow_direction.normalize(), arrow_from[i + n_b - 1][j], arrow_length, 0xffffff);
                cone[cs_count] = new THREE.Mesh(geometryc, materialc);


                cone[cs_count].position.x = ip_x[i - 1 + n_b][j];
                //cone[cs_count].position.y = ip_y[i-1+n_b][j] - 0.5;  

                cone[cs_count].position.y = arrow_to[i + n_b - 1][j].y;//ip_y[i-1][j] + 0.5;

                if (arrow_to[i + n_b - 1][j].y < arrow_from[i + n_b - 1][j].y) {
                    cone[cs_count].rotation.z = 3.14
                }
                //cone[cs_count].rotation.z = 3.14  


                if (step == "fbd" && substep == i + n_b && (subsubstep == -100 || subsubstep == j + 1)) {
                    scene.add(chotasphere[cs_count]);

                }

                if (step == "fbd" && substep == i + n_b && (subsubstep > j + 1 || subsubstep == 100)) {
                    scene.add(chotasphere[cs_count]);
                    scene.add(arrowHelper[cs_count]);
                    scene.add(cone[cs_count]);
                    if (subsubstep == 100) {
                        audio = new Audio(fbdf_audio[i + n_b - 1])
                        //audio.play();
                    }
                }
                cs_count = cs_count + 1;




            }


        }




        //debugger
        //console.log(realpts) 
        const clock = new THREE.Clock()
        var animation_on = 1;
        var line_pos;
        var line_size;
        var Time_tillnow = 0;
        var time_main;
        //debugger
        const tick = () => {
            // Update objects


            //console.log(line.geometry.attributes.position.array)

            //points.push( new THREE.Vector3( 1, 0, 0 ) );
            const elapsedTime = clock.getElapsedTime()

            //line.geometry.attributes.position.needsUpdate = true;
            //line.geometry.attributes.position.array[4] = elapsedTime*0.5;

            //line1.geometry.attributes.position.needsUpdate = true;
            //line1.geometry.attributes.position.array[4] = -elapsedTime*0.5;
            //line.geometry.attributes.position.array[4] = elapsedTime*0.5
            //console.log(line.geometry.attributes.position.array)
            //mesh.position.y = elapsedTime*0.5
            //mesh1.position.y =- elapsedTime*0.5

            // line ka size agar zero approach kar raha to start again wala code hai - abhi ek hi line ke liye likha hai
            // need to do for all lines

            if (step == "motion" || step.includes("constraint")) {
                for (i = 1; i < n_s + 1; i++) {
                    line_pos = linestr[i - 1].geometry.attributes.position.array;
                    line_size = ((line_pos[0] - line_pos[3]) ** 2 + (line_pos[1] - line_pos[4]) ** 2 + (line_pos[2] - line_pos[5]) ** 2) ** 0.5;

                    if (line_size < 1) {
                        animation_on = 0;
                    }
                }

                if (animation_on == 0) {
                    for (i = 1; i < n_b + 1; i++) {

                        meshk[i - 1].position.x = block_ini_pos_x[i - 1];
                        meshk[i - 1].position.y = block_ini_pos_y[i - 1];

                        Time_tillnow = elapsedTime


                    }
                    for (i = 1; i < n_p + 1; i++) {

                        meshp[i - 1].position.x = pulley_ini_pos_x[i - 1];
                        meshp[i - 1].position.y = pulley_ini_pos_y[i - 1];

                        Time_tillnow = elapsedTime


                    }
                    animation_on = 1;
                }

                for (i = 1; i < n_b + 1; i++) {

                    time_main = elapsedTime - Time_tillnow;

                    if (step == "motion" || (step == "constraint" && subsubstep == -1)) {
                        meshk[i - 1].position.x = meshk[i - 1].position.x + 0.5 * (blockdata[i].acceleration[0]) * time_main * time_main / 5000;
                        meshk[i - 1].position.y = meshk[i - 1].position.y + 0.5 * (blockdata[i].acceleration[1]) * time_main * time_main / 5000;
                    }

                    if (step == "constraint" && (stringdata[substep]["first obj type"] == "<class 'blocksclass.blocks'>" || stringdata[substep]["second obj type"] == "<class 'blocksclass.blocks'>")) {
                        if (stringdata[substep]["first obj type"] == "<class 'blocksclass.blocks'>") {
                            if (stringdata[substep]["first obj"] == i && subsubstep == 1) {
                                meshk[i - 1].position.x = meshk[i - 1].position.x + 0.5 * (blockdata[i].acceleration[0]) * time_main * time_main / 5000;
                                meshk[i - 1].position.y = meshk[i - 1].position.y + 0.5 * (blockdata[i].acceleration[1]) * time_main * time_main / 5000;
                            }
                        }

                        if (stringdata[substep]["second obj type"] == "<class 'blocksclass.blocks'>") {
                            if (stringdata[substep]["second obj"] == i && subsubstep == 2) {
                                meshk[i - 1].position.x = meshk[i - 1].position.x + 0.5 * (blockdata[i].acceleration[0]) * time_main * time_main / 5000;
                                meshk[i - 1].position.y = meshk[i - 1].position.y + 0.5 * (blockdata[i].acceleration[1]) * time_main * time_main / 5000;
                            }
                        }


                    }



                }

                // constraint understanding code starts
                if (step == "constraint Understanding") {
                    var points_cu
                    cs_cu[0].position.x = cs_cu[0].position.x + velocity_cu[0] * (elapsedTime - Time_tillnow) / 200
                    cs_cu[1].position.x = cs_cu[1].position.x + velocity_cu[1] * (elapsedTime - Time_tillnow) / 200

                    linestr_cu.geometry.attributes.position.needsUpdate = true;
                    linestr_cu.geometry.attributes.position.array[0] = cs_cu[0].position.x
                    linestr_cu.geometry.attributes.position.array[3] = cs_cu[1].position.x
                    var line_pos_cu
                    var line_size_cu
                    line_pos_cu = linestr_cu.geometry.attributes.position.array;
                    line_size_cu = line_pos_cu[3] - line_pos_cu[0];

                    if (line_size_cu < 0.5 || line_size_cu > 10 || cs_cu[1].position.x > 9) {
                        cs_cu[0].position.x = -0.3
                        cs_cu[1].position.x = 4
                        Time_tillnow = elapsedTime
                    }

                }

                // constraint understanding code ends

                for (i = 1; i < n_p + 1; i++) {

                    time_main = elapsedTime - Time_tillnow;

                    if (step == "motion" || (step == "constraint" && subsubstep == -1)) {
                        meshp[i - 1].position.x = meshp[i - 1].position.x + 0.5 * (pulleydata[i].acceleration[0]) * time_main * time_main / 5000;
                        meshp[i - 1].position.y = meshp[i - 1].position.y + 0.5 * (pulleydata[i].acceleration[1]) * time_main * time_main / 5000;
                    }

                    if (step == "constraint" && (stringdata[substep]["first obj type"] == "<class 'blocksclass.pulleys'>" || stringdata[substep]["second obj type"] == "<class 'blocksclass.pulleys'>")) {
                        if (stringdata[substep]["first obj type"] == "<class 'blocksclass.pulleys'>") {
                            if (stringdata[substep]["first obj"] == i && subsubstep == 1) {
                                meshp[i - 1].position.x = meshp[i - 1].position.x + 0.5 * (pulleydata[i].acceleration[0]) * time_main * time_main / 5000;
                                meshp[i - 1].position.y = meshp[i - 1].position.y + 0.5 * (pulleydata[i].acceleration[1]) * time_main * time_main / 5000;
                            }
                        }

                        if (stringdata[substep]["second obj type"] == "<class 'blocksclass.pulleys'>") {
                            if (stringdata[substep]["second obj"] == i && subsubstep == 2) {
                                meshp[i - 1].position.x = meshp[i - 1].position.x + 0.5 * (pulleydata[i].acceleration[0]) * time_main * time_main / 5000;
                                meshp[i - 1].position.y = meshp[i - 1].position.y + 0.5 * (pulleydata[i].acceleration[1]) * time_main * time_main / 5000;
                            }
                        }


                    }



                }


                cs_count_cons = 0
                for (i = 1; i < n_s + 1; i++) {

                    strpart = stringdata[i];

                    //if( line_size < 0 )
                    //console.log( strpart["first obj type"])
                    if (strpart["first obj type"] == "<class 'blocksclass.blocks'>" && strpart["second obj type"] == "<class 'blocksclass.pulleys'>") {
                        linestr[i - 1].geometry.attributes.position.needsUpdate = true;
                        linestr[i - 1].geometry.attributes.position.array[1] = meshk[stringdata[i]["first obj"] - 1].position.y
                        linestr[i - 1].geometry.attributes.position.array[0] = meshk[stringdata[i]["first obj"] - 1].position.x

                        linestr[i - 1].geometry.attributes.position.array[4] = meshp[stringdata[i]["second obj"] - 1].position.y

                        cs_cons[cs_count_cons].position.x = linestr[i - 1].geometry.attributes.position.array[0]
                        cs_cons[cs_count_cons].position.y = linestr[i - 1].geometry.attributes.position.array[1] + 0.6;

                        cs_count_cons = cs_count_cons + 2



                    }

                    if (strpart["second obj type"] == "<class 'blocksclass.blocks'>" && strpart["first obj type"] == "<class 'blocksclass.pulleys'>") {
                        linestr[i - 1].geometry.attributes.position.needsUpdate = true;
                        linestr[i - 1].geometry.attributes.position.array[3] = meshk[stringdata[i]["second obj"] - 1].position.x
                        linestr[i - 1].geometry.attributes.position.array[4] = meshk[stringdata[i]["second obj"] - 1].position.y

                        linestr[i - 1].geometry.attributes.position.array[1] = meshp[stringdata[i]["first obj"] - 1].position.y

                        cs_cons[cs_count_cons + 1].position.x = linestr[i - 1].geometry.attributes.position.array[3]
                        cs_cons[cs_count_cons + 1].position.y = linestr[i - 1].geometry.attributes.position.array[4] + 0.6;

                        cs_count_cons = cs_count_cons + 2
                    }

                    if (strpart["second obj type"] == "<class 'blocksclass.blocks'>" && strpart["first obj type"] == "<class 'blocksclass.blocks'>") {
                        linestr[i - 1].geometry.attributes.position.needsUpdate = true;
                        linestr[i - 1].geometry.attributes.position.array[1] = meshk[stringdata[i]["first obj"] - 1].position.y
                        linestr[i - 1].geometry.attributes.position.array[4] = meshk[stringdata[i]["second obj"] - 1].position.y

                        cs_cons[cs_count_cons].position.y = linestr[i - 1].geometry.attributes.position.array[1] + 0.6;
                        cs_cons[cs_count_cons + 1].position.y = linestr[i - 1].geometry.attributes.position.array[4] - 0.6;

                        cs_count_cons = cs_count_cons + 2
                    }

                    if (strpart["second obj type"] == "<class 'blocksclass.pulleys'>" && strpart["first obj type"] == "<class 'blocksclass.pulleys'>") {
                        linestr[i - 1].geometry.attributes.position.needsUpdate = true;
                        //linestr[i-1].geometry.attributes.position.array[3] = meshk[stringdata[i]["second obj"] - 1].position.x
                        linestr[i - 1].geometry.attributes.position.array[4] = meshp[stringdata[i]["second obj"] - 1].position.y

                        linestr[i - 1].geometry.attributes.position.array[1] = meshp[stringdata[i]["first obj"] - 1].position.y

                        cs_cons[cs_count_cons + 1].position.x = linestr[i - 1].geometry.attributes.position.array[3]
                        cs_cons[cs_count_cons + 1].position.y = linestr[i - 1].geometry.attributes.position.array[4] + 0.6;

                        cs_count_cons = cs_count_cons + 2
                    }
                    if (strpart["second obj type"] == "<class 'blocksclass.grounds'>" && strpart["first obj type"] == "<class 'blocksclass.pulleys'>") {
                        linestr[i - 1].geometry.attributes.position.needsUpdate = true;
                        //linestr[i-1].geometry.attributes.position.array[3] = meshk[stringdata[i]["second obj"] - 1].position.x
                        //linestr[i-1].geometry.attributes.position.array[4] = meshp[stringdata[i]["second obj"] - 1].position.y

                        linestr[i - 1].geometry.attributes.position.array[1] = meshp[stringdata[i]["first obj"] - 1].position.y

                        cs_cons[cs_count_cons + 1].position.x = linestr[i - 1].geometry.attributes.position.array[3]
                        cs_cons[cs_count_cons + 1].position.y = linestr[i - 1].geometry.attributes.position.array[4] + 0.6;

                        cs_count_cons = cs_count_cons + 2
                    }
                }

            }

            //cylinder.position.y = elapsedTime*0.5


            // Render
            renderer.render(scene, camera)

            // Call tick again on the next frame
            //if( animation_on == 1)

            window.requestAnimationFrame(tick)

        }

        tick()


        //******************************************SHIVAM CODE ENDS */


        mountRef.current.appendChild(renderer.domElement);
        return () => mountRef.current.removeChild(renderer.domElement);
    }, [props]);

    return (
        <div ref={mountRef}>
            <audio src="" id="radio" class="hidden" preload="none"></audio>
        </div>
    );



}

export default React.memo(TestThree);
